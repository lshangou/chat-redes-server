"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Namespace = exports.RESERVED_EVENTS = void 0;

var socket_1 = require("./socket");

var typed_events_1 = require("./typed-events");

var debug_1 = __importDefault(require("debug"));

var broadcast_operator_1 = require("./broadcast-operator");

var debug = debug_1["default"]("socket.io:namespace");
exports.RESERVED_EVENTS = new Set(["connect", "connection", "new_namespace"]);

var Namespace =
/*#__PURE__*/
function (_typed_events_1$Stric) {
  _inherits(Namespace, _typed_events_1$Stric);

  /**
   * Namespace constructor.
   *
   * @param server instance
   * @param name
   */
  function Namespace(server, name) {
    var _this;

    _classCallCheck(this, Namespace);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Namespace).call(this));
    _this.sockets = new Map();
    /** @private */

    _this._fns = [];
    /** @private */

    _this._ids = 0;
    _this.server = server;
    _this.name = name;

    _this._initAdapter();

    return _this;
  }
  /**
   * Initializes the `Adapter` for this nsp.
   * Run upon changing adapter by `Server#adapter`
   * in addition to the constructor.
   *
   * @private
   */


  _createClass(Namespace, [{
    key: "_initAdapter",
    value: function _initAdapter() {
      // @ts-ignore
      this.adapter = new (this.server.adapter())(this);
    }
    /**
     * Sets up namespace middleware.
     *
     * @return self
     * @public
     */

  }, {
    key: "use",
    value: function use(fn) {
      this._fns.push(fn);

      return this;
    }
    /**
     * Executes the middleware for an incoming client.
     *
     * @param socket - the socket that will get added
     * @param fn - last fn call in the middleware
     * @private
     */

  }, {
    key: "run",
    value: function run(socket, fn) {
      var fns = this._fns.slice(0);

      if (!fns.length) return fn(null);

      function run(i) {
        fns[i](socket, function (err) {
          // upon error, short-circuit
          if (err) return fn(err); // if no middleware left, summon callback

          if (!fns[i + 1]) return fn(null); // go on to next

          run(i + 1);
        });
      }

      run(0);
    }
    /**
     * Targets a room when emitting.
     *
     * @param room
     * @return self
     * @public
     */

  }, {
    key: "to",
    value: function to(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).to(room);
    }
    /**
     * Targets a room when emitting.
     *
     * @param room
     * @return self
     * @public
     */

  }, {
    key: "in",
    value: function _in(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter)["in"](room);
    }
    /**
     * Excludes a room when emitting.
     *
     * @param room
     * @return self
     * @public
     */

  }, {
    key: "except",
    value: function except(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).except(room);
    }
    /**
     * Adds a new client.
     *
     * @return {Socket}
     * @private
     */

  }, {
    key: "_add",
    value: function _add(client, query, fn) {
      var _this2 = this;

      debug("adding socket to nsp %s", this.name);
      var socket = new socket_1.Socket(this, client, query);
      this.run(socket, function (err) {
        process.nextTick(function () {
          if ("open" == client.conn.readyState) {
            if (err) {
              if (client.conn.protocol === 3) {
                return socket._error(err.data || err.message);
              } else {
                return socket._error({
                  message: err.message,
                  data: err.data
                });
              }
            } // track socket


            _this2.sockets.set(socket.id, socket); // it's paramount that the internal `onconnect` logic
            // fires before user-set events to prevent state order
            // violations (such as a disconnection before the connection
            // logic is complete)


            socket._onconnect();

            if (fn) fn(); // fire user-set events

            _this2.emitReserved("connect", socket);

            _this2.emitReserved("connection", socket);
          } else {
            debug("next called after client was closed - ignoring socket");
          }
        });
      });
      return socket;
    }
    /**
     * Removes a client. Called by each `Socket`.
     *
     * @private
     */

  }, {
    key: "_remove",
    value: function _remove(socket) {
      if (this.sockets.has(socket.id)) {
        this.sockets["delete"](socket.id);
      } else {
        debug("ignoring remove for %s", socket.id);
      }
    }
    /**
     * Emits to all clients.
     *
     * @return Always true
     * @public
     */

  }, {
    key: "emit",
    value: function emit(ev) {
      var _ref;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return (_ref = new broadcast_operator_1.BroadcastOperator(this.adapter)).emit.apply(_ref, [ev].concat(args));
    }
    /**
     * Sends a `message` event to all clients.
     *
     * @return self
     * @public
     */

  }, {
    key: "send",
    value: function send() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      this.emit.apply(this, ["message"].concat(args));
      return this;
    }
    /**
     * Sends a `message` event to all clients.
     *
     * @return self
     * @public
     */

  }, {
    key: "write",
    value: function write() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      this.emit.apply(this, ["message"].concat(args));
      return this;
    }
    /**
     * Emit a packet to other Socket.IO servers
     *
     * @param ev - the event name
     * @param args - an array of arguments, which may include an acknowledgement callback at the end
     * @public
     */

  }, {
    key: "serverSideEmit",
    value: function serverSideEmit(ev) {
      if (exports.RESERVED_EVENTS.has(ev)) {
        throw new Error("\"".concat(ev, "\" is a reserved event name"));
      }

      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }

      args.unshift(ev);
      this.adapter.serverSideEmit(args);
      return true;
    }
    /**
     * Called when a packet is received from another Socket.IO server
     *
     * @param args - an array of arguments, which may include an acknowledgement callback at the end
     *
     * @private
     */

  }, {
    key: "_onServerSideEmit",
    value: function _onServerSideEmit(args) {
      _get(_getPrototypeOf(Namespace.prototype), "emitUntyped", this).apply(this, args);
    }
    /**
     * Gets a list of clients.
     *
     * @return self
     * @public
     */

  }, {
    key: "allSockets",
    value: function allSockets() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).allSockets();
    }
    /**
     * Sets the compress flag.
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     * @public
     */

  }, {
    key: "compress",
    value: function compress(_compress) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).compress(_compress);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because they’re connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @return self
     * @public
     */

  }, {
    key: "fetchSockets",

    /**
     * Returns the matching socket instances
     *
     * @public
     */
    value: function fetchSockets() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).fetchSockets();
    }
    /**
     * Makes the matching socket instances join the specified rooms
     *
     * @param room
     * @public
     */

  }, {
    key: "socketsJoin",
    value: function socketsJoin(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsJoin(room);
    }
    /**
     * Makes the matching socket instances leave the specified rooms
     *
     * @param room
     * @public
     */

  }, {
    key: "socketsLeave",
    value: function socketsLeave(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsLeave(room);
    }
    /**
     * Makes the matching socket instances disconnect
     *
     * @param close - whether to close the underlying connection
     * @public
     */

  }, {
    key: "disconnectSockets",
    value: function disconnectSockets() {
      var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return new broadcast_operator_1.BroadcastOperator(this.adapter).disconnectSockets(close);
    }
  }, {
    key: "volatile",
    get: function get() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter)["volatile"];
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
     *
     * @return self
     * @public
     */

  }, {
    key: "local",
    get: function get() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).local;
    }
  }]);

  return Namespace;
}(typed_events_1.StrictEventEmitter);

exports.Namespace = Namespace;