"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RemoteSocket = exports.BroadcastOperator = void 0;

var socket_1 = require("./socket");

var socket_io_parser_1 = require("socket.io-parser");

var BroadcastOperator =
/*#__PURE__*/
function () {
  function BroadcastOperator(adapter) {
    var rooms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();
    var exceptRooms = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();
    var flags = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, BroadcastOperator);

    this.adapter = adapter;
    this.rooms = rooms;
    this.exceptRooms = exceptRooms;
    this.flags = flags;
  }
  /**
   * Targets a room when emitting.
   *
   * @param room
   * @return a new BroadcastOperator instance
   * @public
   */


  _createClass(BroadcastOperator, [{
    key: "to",
    value: function to(room) {
      var rooms = new Set(this.rooms);

      if (Array.isArray(room)) {
        room.forEach(function (r) {
          return rooms.add(r);
        });
      } else {
        rooms.add(room);
      }

      return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);
    }
    /**
     * Targets a room when emitting.
     *
     * @param room
     * @return a new BroadcastOperator instance
     * @public
     */

  }, {
    key: "in",
    value: function _in(room) {
      return this.to(room);
    }
    /**
     * Excludes a room when emitting.
     *
     * @param room
     * @return a new BroadcastOperator instance
     * @public
     */

  }, {
    key: "except",
    value: function except(room) {
      var exceptRooms = new Set(this.exceptRooms);

      if (Array.isArray(room)) {
        room.forEach(function (r) {
          return exceptRooms.add(r);
        });
      } else {
        exceptRooms.add(room);
      }

      return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);
    }
    /**
     * Sets the compress flag.
     *
     * @param compress - if `true`, compresses the sending data
     * @return a new BroadcastOperator instance
     * @public
     */

  }, {
    key: "compress",
    value: function compress(_compress) {
      var flags = Object.assign({}, this.flags, {
        compress: _compress
      });
      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because theyâ€™re connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @return a new BroadcastOperator instance
     * @public
     */

  }, {
    key: "emit",

    /**
     * Emits to all clients.
     *
     * @return Always true
     * @public
     */
    value: function emit(ev) {
      if (socket_1.RESERVED_EVENTS.has(ev)) {
        throw new Error("\"".concat(ev, "\" is a reserved event name"));
      } // set up packet object


      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var data = [ev].concat(args);
      var packet = {
        type: socket_io_parser_1.PacketType.EVENT,
        data: data
      };

      if ("function" == typeof data[data.length - 1]) {
        throw new Error("Callbacks are not supported when broadcasting");
      }

      this.adapter.broadcast(packet, {
        rooms: this.rooms,
        except: this.exceptRooms,
        flags: this.flags
      });
      return true;
    }
    /**
     * Gets a list of clients.
     *
     * @public
     */

  }, {
    key: "allSockets",
    value: function allSockets() {
      if (!this.adapter) {
        throw new Error("No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?");
      }

      return this.adapter.sockets(this.rooms);
    }
    /**
     * Returns the matching socket instances
     *
     * @public
     */

  }, {
    key: "fetchSockets",
    value: function fetchSockets() {
      var _this = this;

      return this.adapter.fetchSockets({
        rooms: this.rooms,
        except: this.exceptRooms
      }).then(function (sockets) {
        return sockets.map(function (socket) {
          if (socket instanceof socket_1.Socket) {
            // FIXME the TypeScript compiler complains about missing private properties
            return socket;
          } else {
            return new RemoteSocket(_this.adapter, socket);
          }
        });
      });
    }
    /**
     * Makes the matching socket instances join the specified rooms
     *
     * @param room
     * @public
     */

  }, {
    key: "socketsJoin",
    value: function socketsJoin(room) {
      this.adapter.addSockets({
        rooms: this.rooms,
        except: this.exceptRooms
      }, Array.isArray(room) ? room : [room]);
    }
    /**
     * Makes the matching socket instances leave the specified rooms
     *
     * @param room
     * @public
     */

  }, {
    key: "socketsLeave",
    value: function socketsLeave(room) {
      this.adapter.delSockets({
        rooms: this.rooms,
        except: this.exceptRooms
      }, Array.isArray(room) ? room : [room]);
    }
    /**
     * Makes the matching socket instances disconnect
     *
     * @param close - whether to close the underlying connection
     * @public
     */

  }, {
    key: "disconnectSockets",
    value: function disconnectSockets() {
      var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.adapter.disconnectSockets({
        rooms: this.rooms,
        except: this.exceptRooms
      }, close);
    }
  }, {
    key: "volatile",
    get: function get() {
      var flags = Object.assign({}, this.flags, {
        "volatile": true
      });
      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
     *
     * @return a new BroadcastOperator instance
     * @public
     */

  }, {
    key: "local",
    get: function get() {
      var flags = Object.assign({}, this.flags, {
        local: true
      });
      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
  }]);

  return BroadcastOperator;
}();

exports.BroadcastOperator = BroadcastOperator;
/**
 * Expose of subset of the attributes and methods of the Socket class
 */

var RemoteSocket =
/*#__PURE__*/
function () {
  function RemoteSocket(adapter, details) {
    _classCallCheck(this, RemoteSocket);

    this.id = details.id;
    this.handshake = details.handshake;
    this.rooms = new Set(details.rooms);
    this.data = details.data;
    this.operator = new BroadcastOperator(adapter, new Set([this.id]));
  }

  _createClass(RemoteSocket, [{
    key: "emit",
    value: function emit(ev) {
      var _this$operator;

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return (_this$operator = this.operator).emit.apply(_this$operator, [ev].concat(args));
    }
    /**
     * Joins a room.
     *
     * @param {String|Array} room - room or array of rooms
     * @public
     */

  }, {
    key: "join",
    value: function join(room) {
      return this.operator.socketsJoin(room);
    }
    /**
     * Leaves a room.
     *
     * @param {String} room
     * @public
     */

  }, {
    key: "leave",
    value: function leave(room) {
      return this.operator.socketsLeave(room);
    }
    /**
     * Disconnects this client.
     *
     * @param {Boolean} close - if `true`, closes the underlying connection
     * @return {Socket} self
     *
     * @public
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.operator.disconnectSockets(close);
      return this;
    }
  }]);

  return RemoteSocket;
}();

exports.RemoteSocket = RemoteSocket;