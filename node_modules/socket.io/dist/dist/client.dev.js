"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Client = void 0;

var socket_io_parser_1 = require("socket.io-parser");

var debugModule = require("debug");

var url = require("url");

var debug = debugModule("socket.io:client");

var Client =
/*#__PURE__*/
function () {
  /**
   * Client constructor.
   *
   * @param server instance
   * @param conn
   * @package
   */
  function Client(server, conn) {
    _classCallCheck(this, Client);

    this.sockets = new Map();
    this.nsps = new Map();
    this.server = server;
    this.conn = conn;
    this.encoder = server.encoder;
    this.decoder = new server._parser.Decoder();
    this.id = conn.id;
    this.setup();
  }
  /**
   * @return the reference to the request that originated the Engine.IO connection
   *
   * @public
   */


  _createClass(Client, [{
    key: "setup",

    /**
     * Sets up event listeners.
     *
     * @private
     */
    value: function setup() {
      var _this = this;

      this.onclose = this.onclose.bind(this);
      this.ondata = this.ondata.bind(this);
      this.onerror = this.onerror.bind(this);
      this.ondecoded = this.ondecoded.bind(this); // @ts-ignore

      this.decoder.on("decoded", this.ondecoded);
      this.conn.on("data", this.ondata);
      this.conn.on("error", this.onerror);
      this.conn.on("close", this.onclose);
      this.connectTimeout = setTimeout(function () {
        if (_this.nsps.size === 0) {
          debug("no namespace joined yet, close the client");

          _this.close();
        } else {
          debug("the client has already joined a namespace, nothing to do");
        }
      }, this.server._connectTimeout);
    }
    /**
     * Connects a client to a namespace.
     *
     * @param {String} name - the namespace
     * @param {Object} auth - the auth parameters
     * @private
     */

  }, {
    key: "connect",
    value: function connect(name) {
      var _this2 = this;

      var auth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.server._nsps.has(name)) {
        debug("connecting to namespace %s", name);
        return this.doConnect(name, auth);
      }

      this.server._checkNamespace(name, auth, function (dynamicNspName) {
        if (dynamicNspName) {
          debug("dynamic namespace %s was created", dynamicNspName);

          _this2.doConnect(name, auth);
        } else {
          debug("creation of namespace %s was denied", name);

          _this2._packet({
            type: socket_io_parser_1.PacketType.CONNECT_ERROR,
            nsp: name,
            data: {
              message: "Invalid namespace"
            }
          });
        }
      });
    }
    /**
     * Connects a client to a namespace.
     *
     * @param name - the namespace
     * @param {Object} auth - the auth parameters
     *
     * @private
     */

  }, {
    key: "doConnect",
    value: function doConnect(name, auth) {
      var _this3 = this;

      var nsp = this.server.of(name);

      var socket = nsp._add(this, auth, function () {
        _this3.sockets.set(socket.id, socket);

        _this3.nsps.set(nsp.name, socket);

        if (_this3.connectTimeout) {
          clearTimeout(_this3.connectTimeout);
          _this3.connectTimeout = undefined;
        }
      });
    }
    /**
     * Disconnects from all namespaces and closes transport.
     *
     * @private
     */

  }, {
    key: "_disconnect",
    value: function _disconnect() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.sockets.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var socket = _step.value;
          socket.disconnect();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.sockets.clear();
      this.close();
    }
    /**
     * Removes a socket. Called by each `Socket`.
     *
     * @private
     */

  }, {
    key: "_remove",
    value: function _remove(socket) {
      if (this.sockets.has(socket.id)) {
        var nsp = this.sockets.get(socket.id).nsp.name;
        this.sockets["delete"](socket.id);
        this.nsps["delete"](nsp);
      } else {
        debug("ignoring remove for %s", socket.id);
      }
    }
    /**
     * Closes the underlying connection.
     *
     * @private
     */

  }, {
    key: "close",
    value: function close() {
      if ("open" === this.conn.readyState) {
        debug("forcing transport close");
        this.conn.close();
        this.onclose("forced server close");
      }
    }
    /**
     * Writes a packet to the transport.
     *
     * @param {Object} packet object
     * @param {Object} opts
     * @private
     */

  }, {
    key: "_packet",
    value: function _packet(packet) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.conn.readyState !== "open") {
        debug("ignoring packet write %j", packet);
        return;
      }

      var encodedPackets = this.encoder.encode(packet);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = encodedPackets[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var encodedPacket = _step2.value;
          this.writeToEngine(encodedPacket, opts);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: "writeToEngine",
    value: function writeToEngine(encodedPacket, opts) {
      if (opts["volatile"] && !this.conn.transport.writable) {
        debug("volatile packet is discarded since the transport is not currently writable");
        return;
      }

      this.conn.write(encodedPacket, opts);
    }
    /**
     * Called with incoming transport data.
     *
     * @private
     */

  }, {
    key: "ondata",
    value: function ondata(data) {
      // try/catch is needed for protocol violations (GH-1880)
      try {
        this.decoder.add(data);
      } catch (e) {
        this.onerror(e);
      }
    }
    /**
     * Called when parser fully decodes a packet.
     *
     * @private
     */

  }, {
    key: "ondecoded",
    value: function ondecoded(packet) {
      if (socket_io_parser_1.PacketType.CONNECT === packet.type) {
        if (this.conn.protocol === 3) {
          var parsed = url.parse(packet.nsp, true);
          this.connect(parsed.pathname, parsed.query);
        } else {
          this.connect(packet.nsp, packet.data);
        }
      } else {
        var socket = this.nsps.get(packet.nsp);

        if (socket) {
          process.nextTick(function () {
            socket._onpacket(packet);
          });
        } else {
          debug("no socket for namespace %s", packet.nsp);
        }
      }
    }
    /**
     * Handles an error.
     *
     * @param {Object} err object
     * @private
     */

  }, {
    key: "onerror",
    value: function onerror(err) {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.sockets.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var socket = _step3.value;

          socket._onerror(err);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      this.conn.close();
    }
    /**
     * Called upon transport close.
     *
     * @param reason
     * @private
     */

  }, {
    key: "onclose",
    value: function onclose(reason) {
      debug("client close with reason %s", reason); // ignore a potential subsequent `close` event

      this.destroy(); // `nsps` and `sockets` are cleaned up seamlessly

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this.sockets.values()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var socket = _step4.value;

          socket._onclose(reason);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      this.sockets.clear();
      this.decoder.destroy(); // clean up decoder
    }
    /**
     * Cleans up event listeners.
     * @private
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.conn.removeListener("data", this.ondata);
      this.conn.removeListener("error", this.onerror);
      this.conn.removeListener("close", this.onclose); // @ts-ignore

      this.decoder.removeListener("decoded", this.ondecoded);

      if (this.connectTimeout) {
        clearTimeout(this.connectTimeout);
        this.connectTimeout = undefined;
      }
    }
  }, {
    key: "request",
    get: function get() {
      return this.conn.request;
    }
  }]);

  return Client;
}();

exports.Client = Client;