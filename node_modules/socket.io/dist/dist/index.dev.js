"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }

  __setModuleDefault(result, mod);

  return result;
};

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Namespace = exports.Socket = exports.Server = void 0;

var http = require("http");

var fs_1 = require("fs");

var zlib_1 = require("zlib");

var accepts = require("accepts");

var stream_1 = require("stream");

var path = require("path");

var engine = require("engine.io");

var client_1 = require("./client");

var events_1 = require("events");

var namespace_1 = require("./namespace");

Object.defineProperty(exports, "Namespace", {
  enumerable: true,
  get: function get() {
    return namespace_1.Namespace;
  }
});

var parent_namespace_1 = require("./parent-namespace");

var socket_io_adapter_1 = require("socket.io-adapter");

var parser = __importStar(require("socket.io-parser"));

var debug_1 = __importDefault(require("debug"));

var socket_1 = require("./socket");

Object.defineProperty(exports, "Socket", {
  enumerable: true,
  get: function get() {
    return socket_1.Socket;
  }
});

var typed_events_1 = require("./typed-events");

var debug = debug_1["default"]("socket.io:server");

var clientVersion = require("../package.json").version;

var dotMapRegex = /\.map/;

var Server =
/*#__PURE__*/
function (_typed_events_1$Stric) {
  _inherits(Server, _typed_events_1$Stric);

  function Server(srv) {
    var _this;

    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Server);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Server).call(this));
    /**
     * @private
     */

    _this._nsps = new Map();
    _this.parentNsps = new Map();

    if ("object" === _typeof(srv) && srv instanceof Object && !srv.listen) {
      opts = srv;
      srv = undefined;
    }

    _this.path(opts.path || "/socket.io");

    _this.connectTimeout(opts.connectTimeout || 45000);

    _this.serveClient(false !== opts.serveClient);

    _this._parser = opts.parser || parser;
    _this.encoder = new _this._parser.Encoder();

    _this.adapter(opts.adapter || socket_io_adapter_1.Adapter);

    _this.sockets = _this.of("/");
    _this.opts = opts;
    if (srv) _this.attach(srv);
    return _this;
  }

  _createClass(Server, [{
    key: "serveClient",
    value: function serveClient(v) {
      if (!arguments.length) return this._serveClient;
      this._serveClient = v;
      return this;
    }
    /**
     * Executes the middleware for an incoming namespace not already created on the server.
     *
     * @param name - name of incoming namespace
     * @param auth - the auth parameters
     * @param fn - callback
     *
     * @private
     */

  }, {
    key: "_checkNamespace",
    value: function _checkNamespace(name, auth, fn) {
      var _this2 = this;

      if (this.parentNsps.size === 0) return fn(false);
      var keysIterator = this.parentNsps.keys();

      var run = function run() {
        var nextFn = keysIterator.next();

        if (nextFn.done) {
          return fn(false);
        }

        nextFn.value(name, auth, function (err, allow) {
          if (err || !allow) {
            run();
          } else {
            var namespace = _this2.parentNsps.get(nextFn.value).createChild(name); // @ts-ignore


            _this2.sockets.emitReserved("new_namespace", namespace);

            fn(namespace);
          }
        });
      };

      run();
    }
  }, {
    key: "path",
    value: function path(v) {
      if (!arguments.length) return this._path;
      this._path = v.replace(/\/$/, "");

      var escapedPath = this._path.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");

      this.clientPathRegex = new RegExp("^" + escapedPath + "/socket\\.io(\\.min|\\.msgpack\\.min)?\\.js(\\.map)?$");
      return this;
    }
  }, {
    key: "connectTimeout",
    value: function connectTimeout(v) {
      if (v === undefined) return this._connectTimeout;
      this._connectTimeout = v;
      return this;
    }
  }, {
    key: "adapter",
    value: function adapter(v) {
      if (!arguments.length) return this._adapter;
      this._adapter = v;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._nsps.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var nsp = _step.value;

          nsp._initAdapter();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return this;
    }
    /**
     * Attaches socket.io to a server or port.
     *
     * @param srv - server or port
     * @param opts - options passed to engine.io
     * @return self
     * @public
     */

  }, {
    key: "listen",
    value: function listen(srv) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.attach(srv, opts);
    }
    /**
     * Attaches socket.io to a server or port.
     *
     * @param srv - server or port
     * @param opts - options passed to engine.io
     * @return self
     * @public
     */

  }, {
    key: "attach",
    value: function attach(srv) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if ("function" == typeof srv) {
        var msg = "You are trying to attach socket.io to an express " + "request handler function. Please pass a http.Server instance.";
        throw new Error(msg);
      } // handle a port as a string


      if (Number(srv) == srv) {
        srv = Number(srv);
      }

      if ("number" == typeof srv) {
        debug("creating http server and binding to %d", srv);
        var port = srv;
        srv = http.createServer(function (req, res) {
          res.writeHead(404);
          res.end();
        });
        srv.listen(port);
      } // merge the options passed to the Socket.IO server


      Object.assign(opts, this.opts); // set engine.io path to `/socket.io`

      opts.path = opts.path || this._path;
      this.initEngine(srv, opts);
      return this;
    }
    /**
     * Initialize engine
     *
     * @param srv - the server to attach to
     * @param opts - options passed to engine.io
     * @private
     */

  }, {
    key: "initEngine",
    value: function initEngine(srv, opts) {
      // initialize engine
      debug("creating engine.io instance with opts %j", opts);
      this.eio = engine.attach(srv, opts); // attach static file serving

      if (this._serveClient) this.attachServe(srv); // Export http server

      this.httpServer = srv; // bind to engine events

      this.bind(this.eio);
    }
    /**
     * Attaches the static file serving.
     *
     * @param srv http server
     * @private
     */

  }, {
    key: "attachServe",
    value: function attachServe(srv) {
      var _this3 = this;

      debug("attaching client serving req handler");
      var evs = srv.listeners("request").slice(0);
      srv.removeAllListeners("request");
      srv.on("request", function (req, res) {
        if (_this3.clientPathRegex.test(req.url)) {
          _this3.serve(req, res);
        } else {
          for (var i = 0; i < evs.length; i++) {
            evs[i].call(srv, req, res);
          }
        }
      });
    }
    /**
     * Handles a request serving of client source and map
     *
     * @param req
     * @param res
     * @private
     */

  }, {
    key: "serve",
    value: function serve(req, res) {
      var filename = req.url.replace(this._path, "");
      var isMap = dotMapRegex.test(filename);
      var type = isMap ? "map" : "source"; // Per the standard, ETags must be quoted:
      // https://tools.ietf.org/html/rfc7232#section-2.3

      var expectedEtag = '"' + clientVersion + '"';
      var weakEtag = "W/" + expectedEtag;
      var etag = req.headers["if-none-match"];

      if (etag) {
        if (expectedEtag === etag || weakEtag === etag) {
          debug("serve client %s 304", type);
          res.writeHead(304);
          res.end();
          return;
        }
      }

      debug("serve client %s", type);
      res.setHeader("Cache-Control", "public, max-age=0");
      res.setHeader("Content-Type", "application/" + (isMap ? "json" : "javascript"));
      res.setHeader("ETag", expectedEtag);

      if (!isMap) {
        res.setHeader("X-SourceMap", filename.substring(1) + ".map");
      }

      Server.sendFile(filename, req, res);
    }
    /**
     * @param filename
     * @param req
     * @param res
     * @private
     */

  }, {
    key: "bind",

    /**
     * Binds socket.io to an engine.io instance.
     *
     * @param {engine.Server} engine engine.io (or compatible) server
     * @return self
     * @public
     */
    value: function bind(engine) {
      this.engine = engine;
      this.engine.on("connection", this.onconnection.bind(this));
      return this;
    }
    /**
     * Called with each incoming transport connection.
     *
     * @param {engine.Socket} conn
     * @return self
     * @private
     */

  }, {
    key: "onconnection",
    value: function onconnection(conn) {
      debug("incoming connection with id %s", conn.id);
      var client = new client_1.Client(this, conn);

      if (conn.protocol === 3) {
        // @ts-ignore
        client.connect("/");
      }

      return this;
    }
    /**
     * Looks up a namespace.
     *
     * @param {String|RegExp|Function} name nsp name
     * @param fn optional, nsp `connection` ev handler
     * @public
     */

  }, {
    key: "of",
    value: function of(name, fn) {
      if (typeof name === "function" || name instanceof RegExp) {
        var parentNsp = new parent_namespace_1.ParentNamespace(this);
        debug("initializing parent namespace %s", parentNsp.name);

        if (typeof name === "function") {
          this.parentNsps.set(name, parentNsp);
        } else {
          this.parentNsps.set(function (nsp, conn, next) {
            return next(null, name.test(nsp));
          }, parentNsp);
        }

        if (fn) {
          // @ts-ignore
          parentNsp.on("connect", fn);
        }

        return parentNsp;
      }

      if (String(name)[0] !== "/") name = "/" + name;

      var nsp = this._nsps.get(name);

      if (!nsp) {
        debug("initializing namespace %s", name);
        nsp = new namespace_1.Namespace(this, name);

        this._nsps.set(name, nsp);

        if (name !== "/") {
          // @ts-ignore
          this.sockets.emitReserved("new_namespace", nsp);
        }
      }

      if (fn) nsp.on("connect", fn);
      return nsp;
    }
    /**
     * Closes server connection
     *
     * @param [fn] optional, called as `fn([err])` on error OR all conns closed
     * @public
     */

  }, {
    key: "close",
    value: function close(fn) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.sockets.sockets.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var socket = _step2.value;

          socket._onclose("server shutting down");
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      this.engine.close();

      if (this.httpServer) {
        this.httpServer.close(fn);
      } else {
        fn && fn();
      }
    }
    /**
     * Sets up namespace middleware.
     *
     * @return self
     * @public
     */

  }, {
    key: "use",
    value: function use(fn) {
      this.sockets.use(fn);
      return this;
    }
    /**
     * Targets a room when emitting.
     *
     * @param room
     * @return self
     * @public
     */

  }, {
    key: "to",
    value: function to(room) {
      return this.sockets.to(room);
    }
    /**
     * Targets a room when emitting.
     *
     * @param room
     * @return self
     * @public
     */

  }, {
    key: "in",
    value: function _in(room) {
      return this.sockets["in"](room);
    }
    /**
     * Excludes a room when emitting.
     *
     * @param name
     * @return self
     * @public
     */

  }, {
    key: "except",
    value: function except(name) {
      this.sockets.except(name);
      return this;
    }
    /**
     * Sends a `message` event to all clients.
     *
     * @return self
     * @public
     */

  }, {
    key: "send",
    value: function send() {
      var _this$sockets;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      (_this$sockets = this.sockets).emit.apply(_this$sockets, ["message"].concat(args));

      return this;
    }
    /**
     * Sends a `message` event to all clients.
     *
     * @return self
     * @public
     */

  }, {
    key: "write",
    value: function write() {
      var _this$sockets2;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      (_this$sockets2 = this.sockets).emit.apply(_this$sockets2, ["message"].concat(args));

      return this;
    }
    /**
     * Emit a packet to other Socket.IO servers
     *
     * @param ev - the event name
     * @param args - an array of arguments, which may include an acknowledgement callback at the end
     * @public
     */

  }, {
    key: "serverSideEmit",
    value: function serverSideEmit(ev) {
      var _this$sockets3;

      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      return (_this$sockets3 = this.sockets).serverSideEmit.apply(_this$sockets3, [ev].concat(args));
    }
    /**
     * Gets a list of socket ids.
     *
     * @public
     */

  }, {
    key: "allSockets",
    value: function allSockets() {
      return this.sockets.allSockets();
    }
    /**
     * Sets the compress flag.
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     * @public
     */

  }, {
    key: "compress",
    value: function compress(_compress) {
      return this.sockets.compress(_compress);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because they’re connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @return self
     * @public
     */

  }, {
    key: "fetchSockets",

    /**
     * Returns the matching socket instances
     *
     * @public
     */
    value: function fetchSockets() {
      return this.sockets.fetchSockets();
    }
    /**
     * Makes the matching socket instances join the specified rooms
     *
     * @param room
     * @public
     */

  }, {
    key: "socketsJoin",
    value: function socketsJoin(room) {
      return this.sockets.socketsJoin(room);
    }
    /**
     * Makes the matching socket instances leave the specified rooms
     *
     * @param room
     * @public
     */

  }, {
    key: "socketsLeave",
    value: function socketsLeave(room) {
      return this.sockets.socketsLeave(room);
    }
    /**
     * Makes the matching socket instances disconnect
     *
     * @param close - whether to close the underlying connection
     * @public
     */

  }, {
    key: "disconnectSockets",
    value: function disconnectSockets() {
      var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return this.sockets.disconnectSockets(close);
    }
  }, {
    key: "volatile",
    get: function get() {
      return this.sockets["volatile"];
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
     *
     * @return self
     * @public
     */

  }, {
    key: "local",
    get: function get() {
      return this.sockets.local;
    }
  }], [{
    key: "sendFile",
    value: function sendFile(filename, req, res) {
      var readStream = fs_1.createReadStream(path.join(__dirname, "../client-dist/", filename));
      var encoding = accepts(req).encodings(["br", "gzip", "deflate"]);

      var onError = function onError(err) {
        if (err) {
          res.end();
        }
      };

      switch (encoding) {
        case "br":
          res.writeHead(200, {
            "content-encoding": "br"
          });
          readStream.pipe(zlib_1.createBrotliCompress()).pipe(res);
          stream_1.pipeline(readStream, zlib_1.createBrotliCompress(), res, onError);
          break;

        case "gzip":
          res.writeHead(200, {
            "content-encoding": "gzip"
          });
          stream_1.pipeline(readStream, zlib_1.createGzip(), res, onError);
          break;

        case "deflate":
          res.writeHead(200, {
            "content-encoding": "deflate"
          });
          stream_1.pipeline(readStream, zlib_1.createDeflate(), res, onError);
          break;

        default:
          res.writeHead(200);
          stream_1.pipeline(readStream, res, onError);
      }
    }
  }]);

  return Server;
}(typed_events_1.StrictEventEmitter);

exports.Server = Server;
/**
 * Expose main namespace (/).
 */

var emitterMethods = Object.keys(events_1.EventEmitter.prototype).filter(function (key) {
  return typeof events_1.EventEmitter.prototype[key] === "function";
});
emitterMethods.forEach(function (fn) {
  Server.prototype[fn] = function () {
    return this.sockets[fn].apply(this.sockets, arguments);
  };
});

module.exports = function (srv, opts) {
  return new Server(srv, opts);
};

module.exports.Server = Server;
module.exports.Namespace = namespace_1.Namespace;
module.exports.Socket = socket_1.Socket;