"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var EventEmitter = require("events");

var debug = require("debug")("engine:socket");

var Socket =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(Socket, _EventEmitter);

  /**
   * Client class (abstract).
   *
   * @api private
   */
  function Socket(id, server, transport, req, protocol) {
    var _this;

    _classCallCheck(this, Socket);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Socket).call(this));
    _this.id = id;
    _this.server = server;
    _this.upgrading = false;
    _this.upgraded = false;
    _this.readyState = "opening";
    _this.writeBuffer = [];
    _this.packetsFn = [];
    _this.sentCallbackFn = [];
    _this.cleanupFn = [];
    _this.request = req;
    _this.protocol = protocol; // Cache IP since it might not be in the req later

    if (req.websocket && req.websocket._socket) {
      _this.remoteAddress = req.websocket._socket.remoteAddress;
    } else {
      _this.remoteAddress = req.connection.remoteAddress;
    }

    _this.checkIntervalTimer = null;
    _this.upgradeTimeoutTimer = null;
    _this.pingTimeoutTimer = null;
    _this.pingIntervalTimer = null;

    _this.setTransport(transport);

    _this.onOpen();

    return _this;
  }
  /**
   * Called upon transport considered open.
   *
   * @api private
   */


  _createClass(Socket, [{
    key: "onOpen",
    value: function onOpen() {
      this.readyState = "open"; // sends an `open` packet

      this.transport.sid = this.id;
      this.sendPacket("open", JSON.stringify({
        sid: this.id,
        upgrades: this.getAvailableUpgrades(),
        pingInterval: this.server.opts.pingInterval,
        pingTimeout: this.server.opts.pingTimeout
      }));

      if (this.server.opts.initialPacket) {
        this.sendPacket("message", this.server.opts.initialPacket);
      }

      this.emit("open");

      if (this.protocol === 3) {
        // in protocol v3, the client sends a ping, and the server answers with a pong
        this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);
      } else {
        // in protocol v4, the server sends a ping, and the client answers with a pong
        this.schedulePing();
      }
    }
    /**
     * Called upon transport packet.
     *
     * @param {Object} packet
     * @api private
     */

  }, {
    key: "onPacket",
    value: function onPacket(packet) {
      if ("open" !== this.readyState) {
        return debug("packet received with closed socket");
      } // export packet event


      debug("received packet ".concat(packet.type));
      this.emit("packet", packet); // Reset ping timeout on any packet, incoming data is a good sign of
      // other side's liveness

      this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);

      switch (packet.type) {
        case "ping":
          if (this.transport.protocol !== 3) {
            this.onError("invalid heartbeat direction");
            return;
          }

          debug("got ping");
          this.sendPacket("pong");
          this.emit("heartbeat");
          break;

        case "pong":
          if (this.transport.protocol === 3) {
            this.onError("invalid heartbeat direction");
            return;
          }

          debug("got pong");
          this.schedulePing();
          this.emit("heartbeat");
          break;

        case "error":
          this.onClose("parse error");
          break;

        case "message":
          this.emit("data", packet.data);
          this.emit("message", packet.data);
          break;
      }
    }
    /**
     * Called upon transport error.
     *
     * @param {Error} error object
     * @api private
     */

  }, {
    key: "onError",
    value: function onError(err) {
      debug("transport error");
      this.onClose("transport error", err);
    }
    /**
     * Pings client every `this.pingInterval` and expects response
     * within `this.pingTimeout` or closes connection.
     *
     * @api private
     */

  }, {
    key: "schedulePing",
    value: function schedulePing() {
      var _this2 = this;

      clearTimeout(this.pingIntervalTimer);
      this.pingIntervalTimer = setTimeout(function () {
        debug("writing ping packet - expecting pong within %sms", _this2.server.opts.pingTimeout);

        _this2.sendPacket("ping");

        _this2.resetPingTimeout(_this2.server.opts.pingTimeout);
      }, this.server.opts.pingInterval);
    }
    /**
     * Resets ping timeout.
     *
     * @api private
     */

  }, {
    key: "resetPingTimeout",
    value: function resetPingTimeout(timeout) {
      var _this3 = this;

      clearTimeout(this.pingTimeoutTimer);
      this.pingTimeoutTimer = setTimeout(function () {
        if (_this3.readyState === "closed") return;

        _this3.onClose("ping timeout");
      }, timeout);
    }
    /**
     * Attaches handlers for the given transport.
     *
     * @param {Transport} transport
     * @api private
     */

  }, {
    key: "setTransport",
    value: function setTransport(transport) {
      var onError = this.onError.bind(this);
      var onPacket = this.onPacket.bind(this);
      var flush = this.flush.bind(this);
      var onClose = this.onClose.bind(this, "transport close");
      this.transport = transport;
      this.transport.once("error", onError);
      this.transport.on("packet", onPacket);
      this.transport.on("drain", flush);
      this.transport.once("close", onClose); // this function will manage packet events (also message callbacks)

      this.setupSendCallback();
      this.cleanupFn.push(function () {
        transport.removeListener("error", onError);
        transport.removeListener("packet", onPacket);
        transport.removeListener("drain", flush);
        transport.removeListener("close", onClose);
      });
    }
    /**
     * Upgrades socket to the given transport
     *
     * @param {Transport} transport
     * @api private
     */

  }, {
    key: "maybeUpgrade",
    value: function maybeUpgrade(transport) {
      var _this4 = this;

      debug('might upgrade socket transport from "%s" to "%s"', this.transport.name, transport.name);
      this.upgrading = true; // set transport upgrade timer

      this.upgradeTimeoutTimer = setTimeout(function () {
        debug("client did not complete upgrade - closing transport");
        cleanup();

        if ("open" === transport.readyState) {
          transport.close();
        }
      }, this.server.opts.upgradeTimeout);

      var onPacket = function onPacket(packet) {
        if ("ping" === packet.type && "probe" === packet.data) {
          transport.send([{
            type: "pong",
            data: "probe"
          }]);

          _this4.emit("upgrading", transport);

          clearInterval(_this4.checkIntervalTimer);
          _this4.checkIntervalTimer = setInterval(check, 100);
        } else if ("upgrade" === packet.type && _this4.readyState !== "closed") {
          debug("got upgrade packet - upgrading");
          cleanup();

          _this4.transport.discard();

          _this4.upgraded = true;

          _this4.clearTransport();

          _this4.setTransport(transport);

          _this4.emit("upgrade", transport);

          _this4.flush();

          if (_this4.readyState === "closing") {
            transport.close(function () {
              _this4.onClose("forced close");
            });
          }
        } else {
          cleanup();
          transport.close();
        }
      }; // we force a polling cycle to ensure a fast upgrade


      var check = function check() {
        if ("polling" === _this4.transport.name && _this4.transport.writable) {
          debug("writing a noop packet to polling for fast upgrade");

          _this4.transport.send([{
            type: "noop"
          }]);
        }
      };

      var cleanup = function cleanup() {
        _this4.upgrading = false;
        clearInterval(_this4.checkIntervalTimer);
        _this4.checkIntervalTimer = null;
        clearTimeout(_this4.upgradeTimeoutTimer);
        _this4.upgradeTimeoutTimer = null;
        transport.removeListener("packet", onPacket);
        transport.removeListener("close", onTransportClose);
        transport.removeListener("error", onError);

        _this4.removeListener("close", onClose);
      };

      var onError = function onError(err) {
        debug("client did not complete upgrade - %s", err);
        cleanup();
        transport.close();
        transport = null;
      };

      var onTransportClose = function onTransportClose() {
        onError("transport closed");
      };

      var onClose = function onClose() {
        onError("socket closed");
      };

      transport.on("packet", onPacket);
      transport.once("close", onTransportClose);
      transport.once("error", onError);
      this.once("close", onClose);
    }
    /**
     * Clears listeners and timers associated with current transport.
     *
     * @api private
     */

  }, {
    key: "clearTransport",
    value: function clearTransport() {
      var cleanup;
      var toCleanUp = this.cleanupFn.length;

      for (var i = 0; i < toCleanUp; i++) {
        cleanup = this.cleanupFn.shift();
        cleanup();
      } // silence further transport errors and prevent uncaught exceptions


      this.transport.on("error", function () {
        debug("error triggered by discarded transport");
      }); // ensure transport won't stay open

      this.transport.close();
      clearTimeout(this.pingTimeoutTimer);
    }
    /**
     * Called upon transport considered closed.
     * Possible reasons: `ping timeout`, `client error`, `parse error`,
     * `transport error`, `server close`, `transport close`
     */

  }, {
    key: "onClose",
    value: function onClose(reason, description) {
      var _this5 = this;

      if ("closed" !== this.readyState) {
        this.readyState = "closed"; // clear timers

        clearTimeout(this.pingIntervalTimer);
        clearTimeout(this.pingTimeoutTimer);
        clearInterval(this.checkIntervalTimer);
        this.checkIntervalTimer = null;
        clearTimeout(this.upgradeTimeoutTimer); // clean writeBuffer in next tick, so developers can still
        // grab the writeBuffer on 'close' event

        process.nextTick(function () {
          _this5.writeBuffer = [];
        });
        this.packetsFn = [];
        this.sentCallbackFn = [];
        this.clearTransport();
        this.emit("close", reason, description);
      }
    }
    /**
     * Setup and manage send callback
     *
     * @api private
     */

  }, {
    key: "setupSendCallback",
    value: function setupSendCallback() {
      var _this6 = this;

      // the message was sent successfully, execute the callback
      var onDrain = function onDrain() {
        if (_this6.sentCallbackFn.length > 0) {
          var seqFn = _this6.sentCallbackFn.splice(0, 1)[0];

          if ("function" === typeof seqFn) {
            debug("executing send callback");
            seqFn(_this6.transport);
          } else if (Array.isArray(seqFn)) {
            debug("executing batch send callback");
            var l = seqFn.length;
            var i = 0;

            for (; i < l; i++) {
              if ("function" === typeof seqFn[i]) {
                seqFn[i](_this6.transport);
              }
            }
          }
        }
      };

      this.transport.on("drain", onDrain);
      this.cleanupFn.push(function () {
        _this6.transport.removeListener("drain", onDrain);
      });
    }
    /**
     * Sends a message packet.
     *
     * @param {String} message
     * @param {Object} options
     * @param {Function} callback
     * @return {Socket} for chaining
     * @api public
     */

  }, {
    key: "send",
    value: function send(data, options, callback) {
      this.sendPacket("message", data, options, callback);
      return this;
    }
  }, {
    key: "write",
    value: function write(data, options, callback) {
      this.sendPacket("message", data, options, callback);
      return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} packet type
     * @param {String} optional, data
     * @param {Object} options
     * @api private
     */

  }, {
    key: "sendPacket",
    value: function sendPacket(type, data, options, callback) {
      if ("function" === typeof options) {
        callback = options;
        options = null;
      }

      options = options || {};
      options.compress = false !== options.compress;

      if ("closing" !== this.readyState && "closed" !== this.readyState) {
        debug('sending packet "%s" (%s)', type, data);
        var packet = {
          type: type,
          options: options
        };
        if (data) packet.data = data; // exports packetCreate event

        this.emit("packetCreate", packet);
        this.writeBuffer.push(packet); // add send callback to object, if defined

        if (callback) this.packetsFn.push(callback);
        this.flush();
      }
    }
    /**
     * Attempts to flush the packets buffer.
     *
     * @api private
     */

  }, {
    key: "flush",
    value: function flush() {
      if ("closed" !== this.readyState && this.transport.writable && this.writeBuffer.length) {
        debug("flushing buffer to transport");
        this.emit("flush", this.writeBuffer);
        this.server.emit("flush", this, this.writeBuffer);
        var wbuf = this.writeBuffer;
        this.writeBuffer = [];

        if (!this.transport.supportsFraming) {
          this.sentCallbackFn.push(this.packetsFn);
        } else {
          this.sentCallbackFn.push.apply(this.sentCallbackFn, this.packetsFn);
        }

        this.packetsFn = [];
        this.transport.send(wbuf);
        this.emit("drain");
        this.server.emit("drain", this);
      }
    }
    /**
     * Get available upgrades for this socket.
     *
     * @api private
     */

  }, {
    key: "getAvailableUpgrades",
    value: function getAvailableUpgrades() {
      var availableUpgrades = [];
      var allUpgrades = this.server.upgrades(this.transport.name);
      var i = 0;
      var l = allUpgrades.length;

      for (; i < l; ++i) {
        var upg = allUpgrades[i];

        if (this.server.opts.transports.indexOf(upg) !== -1) {
          availableUpgrades.push(upg);
        }
      }

      return availableUpgrades;
    }
    /**
     * Closes the socket and underlying transport.
     *
     * @param {Boolean} optional, discard
     * @return {Socket} for chaining
     * @api public
     */

  }, {
    key: "close",
    value: function close(discard) {
      if ("open" !== this.readyState) return;
      this.readyState = "closing";

      if (this.writeBuffer.length) {
        this.once("drain", this.closeTransport.bind(this, discard));
        return;
      }

      this.closeTransport(discard);
    }
    /**
     * Closes the underlying transport.
     *
     * @param {Boolean} discard
     * @api private
     */

  }, {
    key: "closeTransport",
    value: function closeTransport(discard) {
      if (discard) this.transport.discard();
      this.transport.close(this.onClose.bind(this, "forced close"));
    }
  }]);

  return Socket;
}(EventEmitter);

module.exports = Socket;