"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var qs = require("querystring");

var parse = require("url").parse;

var base64id = require("base64id");

var transports = require("./transports");

var EventEmitter = require("events").EventEmitter;

var Socket = require("./socket");

var debug = require("debug")("engine");

var cookieMod = require("cookie");

var DEFAULT_WS_ENGINE = require("ws").Server;

var Server =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(Server, _EventEmitter);

  /**
   * Server constructor.
   *
   * @param {Object} options
   * @api public
   */
  function Server() {
    var _this;

    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Server);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Server).call(this));
    _this.clients = {};
    _this.clientsCount = 0;
    _this.opts = Object.assign({
      wsEngine: DEFAULT_WS_ENGINE,
      pingTimeout: 20000,
      pingInterval: 25000,
      upgradeTimeout: 10000,
      maxHttpBufferSize: 1e6,
      transports: Object.keys(transports),
      allowUpgrades: true,
      httpCompression: {
        threshold: 1024
      },
      cors: false,
      allowEIO3: false
    }, opts);

    if (opts.cookie) {
      _this.opts.cookie = Object.assign({
        name: "io",
        path: "/",
        httpOnly: opts.cookie.path !== false,
        sameSite: "lax"
      }, opts.cookie);
    }

    if (_this.opts.cors) {
      _this.corsMiddleware = require("cors")(_this.opts.cors);
    }

    if (opts.perMessageDeflate) {
      _this.opts.perMessageDeflate = Object.assign({
        threshold: 1024
      }, opts.perMessageDeflate);
    }

    _this.init();

    return _this;
  }
  /**
   * Initialize websocket server
   *
   * @api private
   */


  _createClass(Server, [{
    key: "init",
    value: function init() {
      var _this2 = this;

      if (!~this.opts.transports.indexOf("websocket")) return;
      if (this.ws) this.ws.close();
      this.ws = new this.opts.wsEngine({
        noServer: true,
        clientTracking: false,
        perMessageDeflate: this.opts.perMessageDeflate,
        maxPayload: this.opts.maxHttpBufferSize
      });

      if (typeof this.ws.on === "function") {
        this.ws.on("headers", function (headersArray, req) {
          // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)
          // we could also try to parse the array and then sync the values, but that will be error-prone
          var additionalHeaders = {};
          var isInitialRequest = !req._query.sid;

          if (isInitialRequest) {
            _this2.emit("initial_headers", additionalHeaders, req);
          }

          _this2.emit("headers", additionalHeaders, req);

          Object.keys(additionalHeaders).forEach(function (key) {
            headersArray.push("".concat(key, ": ").concat(additionalHeaders[key]));
          });
        });
      }
    }
    /**
     * Returns a list of available transports for upgrade given a certain transport.
     *
     * @return {Array}
     * @api public
     */

  }, {
    key: "upgrades",
    value: function upgrades(transport) {
      if (!this.opts.allowUpgrades) return [];
      return transports[transport].upgradesTo || [];
    }
    /**
     * Verifies a request.
     *
     * @param {http.IncomingMessage}
     * @return {Boolean} whether the request is valid
     * @api private
     */

  }, {
    key: "verify",
    value: function verify(req, upgrade, fn) {
      // transport check
      var transport = req._query.transport;

      if (!~this.opts.transports.indexOf(transport)) {
        debug('unknown transport "%s"', transport);
        return fn(Server.errors.UNKNOWN_TRANSPORT, {
          transport: transport
        });
      } // 'Origin' header check


      var isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);

      if (isOriginInvalid) {
        var origin = req.headers.origin;
        req.headers.origin = null;
        debug("origin header invalid");
        return fn(Server.errors.BAD_REQUEST, {
          name: "INVALID_ORIGIN",
          origin: origin
        });
      } // sid check


      var sid = req._query.sid;

      if (sid) {
        if (!this.clients.hasOwnProperty(sid)) {
          debug('unknown sid "%s"', sid);
          return fn(Server.errors.UNKNOWN_SID, {
            sid: sid
          });
        }

        var previousTransport = this.clients[sid].transport.name;

        if (!upgrade && previousTransport !== transport) {
          debug("bad request: unexpected transport without upgrade");
          return fn(Server.errors.BAD_REQUEST, {
            name: "TRANSPORT_MISMATCH",
            transport: transport,
            previousTransport: previousTransport
          });
        }
      } else {
        // handshake is GET only
        if ("GET" !== req.method) {
          return fn(Server.errors.BAD_HANDSHAKE_METHOD, {
            method: req.method
          });
        }

        if (!this.opts.allowRequest) return fn();
        return this.opts.allowRequest(req, function (message, success) {
          if (!success) {
            return fn(Server.errors.FORBIDDEN, {
              message: message
            });
          }

          fn();
        });
      }

      fn();
    }
    /**
     * Prepares a request by processing the query string.
     *
     * @api private
     */

  }, {
    key: "prepare",
    value: function prepare(req) {
      // try to leverage pre-existing `req._query` (e.g: from connect)
      if (!req._query) {
        req._query = ~req.url.indexOf("?") ? qs.parse(parse(req.url).query) : {};
      }
    }
    /**
     * Closes all clients.
     *
     * @api public
     */

  }, {
    key: "close",
    value: function close() {
      debug("closing all open clients");

      for (var i in this.clients) {
        if (this.clients.hasOwnProperty(i)) {
          this.clients[i].close(true);
        }
      }

      if (this.ws) {
        debug("closing webSocketServer");
        this.ws.close(); // don't delete this.ws because it can be used again if the http server starts listening again
      }

      return this;
    }
    /**
     * Handles an Engine.IO HTTP request.
     *
     * @param {http.IncomingMessage} request
     * @param {http.ServerResponse|http.OutgoingMessage} response
     * @api public
     */

  }, {
    key: "handleRequest",
    value: function handleRequest(req, res) {
      var _this3 = this;

      debug('handling "%s" http request "%s"', req.method, req.url);
      this.prepare(req);
      req.res = res;

      var callback = function callback(errorCode, errorContext) {
        if (errorCode !== undefined) {
          _this3.emit("connection_error", {
            req: req,
            code: errorCode,
            message: Server.errorMessages[errorCode],
            context: errorContext
          });

          sendErrorMessage(req, res, errorCode, errorContext);
          return;
        }

        if (req._query.sid) {
          debug("setting new request for existing client");

          _this3.clients[req._query.sid].transport.onRequest(req);
        } else {
          _this3.handshake(req._query.transport, req);
        }
      };

      if (this.corsMiddleware) {
        this.corsMiddleware.call(null, req, res, function () {
          _this3.verify(req, false, callback);
        });
      } else {
        this.verify(req, false, callback);
      }
    }
    /**
     * generate a socket id.
     * Overwrite this method to generate your custom socket id
     *
     * @param {Object} request object
     * @api public
     */

  }, {
    key: "generateId",
    value: function generateId(req) {
      return base64id.generateId();
    }
    /**
     * Handshakes a new client.
     *
     * @param {String} transport name
     * @param {Object} request object
     * @api private
     */

  }, {
    key: "handshake",
    value: function handshake(transportName, req) {
      var _this4 = this;

      var protocol, id, transport, socket;
      return regeneratorRuntime.async(function handshake$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              protocol = req._query.EIO === "4" ? 4 : 3; // 3rd revision by default

              if (!(protocol === 3 && !this.opts.allowEIO3)) {
                _context.next = 6;
                break;
              }

              debug("unsupported protocol version");
              this.emit("connection_error", {
                req: req,
                code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,
                message: Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],
                context: {
                  protocol: protocol
                }
              });
              sendErrorMessage(req, req.res, Server.errors.UNSUPPORTED_PROTOCOL_VERSION);
              return _context.abrupt("return");

            case 6:
              _context.prev = 6;
              _context.next = 9;
              return regeneratorRuntime.awrap(this.generateId(req));

            case 9:
              id = _context.sent;
              _context.next = 18;
              break;

            case 12:
              _context.prev = 12;
              _context.t0 = _context["catch"](6);
              debug("error while generating an id");
              this.emit("connection_error", {
                req: req,
                code: Server.errors.BAD_REQUEST,
                message: Server.errorMessages[Server.errors.BAD_REQUEST],
                context: {
                  name: "ID_GENERATION_ERROR",
                  error: _context.t0
                }
              });
              sendErrorMessage(req, req.res, Server.errors.BAD_REQUEST);
              return _context.abrupt("return");

            case 18:
              debug('handshaking client "%s"', id);
              _context.prev = 19;
              transport = new transports[transportName](req);

              if ("polling" === transportName) {
                transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;
                transport.httpCompression = this.opts.httpCompression;
              } else if ("websocket" === transportName) {
                transport.perMessageDeflate = this.opts.perMessageDeflate;
              }

              if (req._query && req._query.b64) {
                transport.supportsBinary = false;
              } else {
                transport.supportsBinary = true;
              }

              _context.next = 31;
              break;

            case 25:
              _context.prev = 25;
              _context.t1 = _context["catch"](19);
              debug('error handshaking to transport "%s"', transportName);
              this.emit("connection_error", {
                req: req,
                code: Server.errors.BAD_REQUEST,
                message: Server.errorMessages[Server.errors.BAD_REQUEST],
                context: {
                  name: "TRANSPORT_HANDSHAKE_ERROR",
                  error: _context.t1
                }
              });
              sendErrorMessage(req, req.res, Server.errors.BAD_REQUEST);
              return _context.abrupt("return");

            case 31:
              socket = new Socket(id, this, transport, req, protocol);
              transport.on("headers", function (headers, req) {
                var isInitialRequest = !req._query.sid;

                if (isInitialRequest) {
                  if (_this4.opts.cookie) {
                    headers["Set-Cookie"] = [cookieMod.serialize(_this4.opts.cookie.name, id, _this4.opts.cookie)];
                  }

                  _this4.emit("initial_headers", headers, req);
                }

                _this4.emit("headers", headers, req);
              });
              transport.onRequest(req);
              this.clients[id] = socket;
              this.clientsCount++;
              socket.once("close", function () {
                delete _this4.clients[id];
                _this4.clientsCount--;
              });
              this.emit("connection", socket);

            case 38:
            case "end":
              return _context.stop();
          }
        }
      }, null, this, [[6, 12], [19, 25]]);
    }
    /**
     * Handles an Engine.IO HTTP Upgrade.
     *
     * @api public
     */

  }, {
    key: "handleUpgrade",
    value: function handleUpgrade(req, socket, upgradeHead) {
      var _this5 = this;

      this.prepare(req);
      this.verify(req, true, function (errorCode, errorContext) {
        if (errorCode) {
          _this5.emit("connection_error", {
            req: req,
            code: errorCode,
            message: Server.errorMessages[errorCode],
            context: errorContext
          });

          abortConnection(socket, errorCode, errorContext);
          return;
        }

        var head = Buffer.from(upgradeHead); // eslint-disable-line node/no-deprecated-api

        upgradeHead = null; // delegate to ws

        _this5.ws.handleUpgrade(req, socket, head, function (conn) {
          _this5.onWebSocket(req, conn);
        });
      });
    }
    /**
     * Called upon a ws.io connection.
     *
     * @param {ws.Socket} websocket
     * @api private
     */

  }, {
    key: "onWebSocket",
    value: function onWebSocket(req, socket) {
      socket.on("error", onUpgradeError);

      if (transports[req._query.transport] !== undefined && !transports[req._query.transport].prototype.handlesUpgrades) {
        debug("transport doesnt handle upgraded requests");
        socket.close();
        return;
      } // get client id


      var id = req._query.sid; // keep a reference to the ws.Socket

      req.websocket = socket;

      if (id) {
        var client = this.clients[id];

        if (!client) {
          debug("upgrade attempt for closed client");
          socket.close();
        } else if (client.upgrading) {
          debug("transport has already been trying to upgrade");
          socket.close();
        } else if (client.upgraded) {
          debug("transport had already been upgraded");
          socket.close();
        } else {
          debug("upgrading existing transport"); // transport error handling takes over

          socket.removeListener("error", onUpgradeError);
          var transport = new transports[req._query.transport](req);

          if (req._query && req._query.b64) {
            transport.supportsBinary = false;
          } else {
            transport.supportsBinary = true;
          }

          transport.perMessageDeflate = this.perMessageDeflate;
          client.maybeUpgrade(transport);
        }
      } else {
        // transport error handling takes over
        socket.removeListener("error", onUpgradeError);
        this.handshake(req._query.transport, req);
      }

      function onUpgradeError() {
        debug("websocket error before upgrade"); // socket.close() not needed
      }
    }
    /**
     * Captures upgrade requests for a http.Server.
     *
     * @param {http.Server} server
     * @param {Object} options
     * @api public
     */

  }, {
    key: "attach",
    value: function attach(server) {
      var _this6 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var path = (options.path || "/engine.io").replace(/\/$/, "");
      var destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000; // normalize path

      path += "/";

      function check(req) {
        return path === req.url.substr(0, path.length);
      } // cache and clean up listeners


      var listeners = server.listeners("request").slice(0);
      server.removeAllListeners("request");
      server.on("close", this.close.bind(this));
      server.on("listening", this.init.bind(this)); // add request handler

      server.on("request", function (req, res) {
        if (check(req)) {
          debug('intercepting request for path "%s"', path);

          _this6.handleRequest(req, res);
        } else {
          var i = 0;
          var l = listeners.length;

          for (; i < l; i++) {
            listeners[i].call(server, req, res);
          }
        }
      });

      if (~this.opts.transports.indexOf("websocket")) {
        server.on("upgrade", function (req, socket, head) {
          if (check(req)) {
            _this6.handleUpgrade(req, socket, head);
          } else if (false !== options.destroyUpgrade) {
            // default node behavior is to disconnect when no handlers
            // but by adding a handler, we prevent that
            // and if no eio thing handles the upgrade
            // then the socket needs to die!
            setTimeout(function () {
              if (socket.writable && socket.bytesWritten <= 0) {
                return socket.end();
              }
            }, destroyUpgradeTimeout);
          }
        });
      }
    }
  }]);

  return Server;
}(EventEmitter);
/**
 * Protocol errors mappings.
 */


Server.errors = {
  UNKNOWN_TRANSPORT: 0,
  UNKNOWN_SID: 1,
  BAD_HANDSHAKE_METHOD: 2,
  BAD_REQUEST: 3,
  FORBIDDEN: 4,
  UNSUPPORTED_PROTOCOL_VERSION: 5
};
Server.errorMessages = {
  0: "Transport unknown",
  1: "Session ID unknown",
  2: "Bad handshake method",
  3: "Bad request",
  4: "Forbidden",
  5: "Unsupported protocol version"
};
/**
 * Sends an Engine.IO Error Message
 *
 * @param req - the request object
 * @param res - the response object
 * @param errorCode - the error code
 * @param errorContext - additional error context
 *
 * @api private
 */

function sendErrorMessage(req, res, errorCode, errorContext) {
  var statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;
  var message = errorContext && errorContext.message ? errorContext.message : Server.errorMessages[errorCode];
  res.writeHead(statusCode, {
    "Content-Type": "application/json"
  });
  res.end(JSON.stringify({
    code: errorCode,
    message: message
  }));
}
/**
 * Closes the connection
 *
 * @param {net.Socket} socket
 * @param {string} errorCode - the error code
 * @param {object} errorContext - additional error context
 *
 * @api private
 */


function abortConnection(socket, errorCode, errorContext) {
  socket.on("error", function () {
    debug("ignoring error from closed connection");
  });

  if (socket.writable) {
    var message = errorContext.message || Server.errorMessages[errorCode];
    var length = Buffer.byteLength(message);
    socket.write("HTTP/1.1 400 Bad Request\r\n" + "Connection: close\r\n" + "Content-type: text/html\r\n" + "Content-Length: " + length + "\r\n" + "\r\n" + message);
  }

  socket.destroy();
}

module.exports = Server;
/* eslint-disable */

/**
 * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354
 *
 * True if val contains an invalid field-vchar
 *  field-value    = *( field-content / obs-fold )
 *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
 *  field-vchar    = VCHAR / obs-text
 *
 * checkInvalidHeaderChar() is currently designed to be inlinable by v8,
 * so take care when making changes to the implementation so that the source
 * code size does not exceed v8's default max_inlined_source_size setting.
 **/
// prettier-ignore

var validHdrChars = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, // 0 - 15
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 32 - 47
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 48 - 63
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 80 - 95
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, // 112 - 127
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 128 ...
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // ... 255
];

function checkInvalidHeaderChar(val) {
  val += "";
  if (val.length < 1) return false;

  if (!validHdrChars[val.charCodeAt(0)]) {
    debug('invalid header, index 0, char "%s"', val.charCodeAt(0));
    return true;
  }

  if (val.length < 2) return false;

  if (!validHdrChars[val.charCodeAt(1)]) {
    debug('invalid header, index 1, char "%s"', val.charCodeAt(1));
    return true;
  }

  if (val.length < 3) return false;

  if (!validHdrChars[val.charCodeAt(2)]) {
    debug('invalid header, index 2, char "%s"', val.charCodeAt(2));
    return true;
  }

  if (val.length < 4) return false;

  if (!validHdrChars[val.charCodeAt(3)]) {
    debug('invalid header, index 3, char "%s"', val.charCodeAt(3));
    return true;
  }

  for (var i = 4; i < val.length; ++i) {
    if (!validHdrChars[val.charCodeAt(i)]) {
      debug('invalid header, index "%i", char "%s"', i, val.charCodeAt(i));
      return true;
    }
  }

  return false;
}