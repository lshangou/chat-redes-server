"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Transport = require("../transport");

var zlib = require("zlib");

var accepts = require("accepts");

var debug = require("debug")("engine:polling");

var compressionMethods = {
  gzip: zlib.createGzip,
  deflate: zlib.createDeflate
};

var Polling =
/*#__PURE__*/
function (_Transport) {
  _inherits(Polling, _Transport);

  /**
   * HTTP polling constructor.
   *
   * @api public.
   */
  function Polling(req) {
    var _this;

    _classCallCheck(this, Polling);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Polling).call(this, req));
    _this.closeTimeout = 30 * 1000;
    _this.maxHttpBufferSize = null;
    _this.httpCompression = null;
    return _this;
  }
  /**
   * Transport name
   *
   * @api public
   */


  _createClass(Polling, [{
    key: "onRequest",

    /**
     * Overrides onRequest.
     *
     * @param {http.IncomingMessage}
     * @api private
     */
    value: function onRequest(req) {
      var res = req.res;

      if ("GET" === req.method) {
        this.onPollRequest(req, res);
      } else if ("POST" === req.method) {
        this.onDataRequest(req, res);
      } else {
        res.writeHead(500);
        res.end();
      }
    }
    /**
     * The client sends a request awaiting for us to send data.
     *
     * @api private
     */

  }, {
    key: "onPollRequest",
    value: function onPollRequest(req, res) {
      var _this2 = this;

      if (this.req) {
        debug("request overlap"); // assert: this.res, '.req and .res should be (un)set together'

        this.onError("overlap from client");
        res.writeHead(500);
        res.end();
        return;
      }

      debug("setting request");
      this.req = req;
      this.res = res;

      var onClose = function onClose() {
        _this2.onError("poll connection closed prematurely");
      };

      var cleanup = function cleanup() {
        req.removeListener("close", onClose);
        _this2.req = _this2.res = null;
      };

      req.cleanup = cleanup;
      req.on("close", onClose);
      this.writable = true;
      this.emit("drain"); // if we're still writable but had a pending close, trigger an empty send

      if (this.writable && this.shouldClose) {
        debug("triggering empty send to append close packet");
        this.send([{
          type: "noop"
        }]);
      }
    }
    /**
     * The client sends a request with data.
     *
     * @api private
     */

  }, {
    key: "onDataRequest",
    value: function onDataRequest(req, res) {
      var _this3 = this;

      if (this.dataReq) {
        // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'
        this.onError("data request overlap from client");
        res.writeHead(500);
        res.end();
        return;
      }

      var isBinary = "application/octet-stream" === req.headers["content-type"];

      if (isBinary && this.protocol === 4) {
        return this.onError("invalid content");
      }

      this.dataReq = req;
      this.dataRes = res;
      var chunks = isBinary ? Buffer.concat([]) : "";

      var cleanup = function cleanup() {
        req.removeListener("data", onData);
        req.removeListener("end", onEnd);
        req.removeListener("close", onClose);
        _this3.dataReq = _this3.dataRes = chunks = null;
      };

      var onClose = function onClose() {
        cleanup();

        _this3.onError("data request connection closed prematurely");
      };

      var onData = function onData(data) {
        var contentLength;

        if (isBinary) {
          chunks = Buffer.concat([chunks, data]);
          contentLength = chunks.length;
        } else {
          chunks += data;
          contentLength = Buffer.byteLength(chunks);
        }

        if (contentLength > _this3.maxHttpBufferSize) {
          chunks = isBinary ? Buffer.concat([]) : "";
          req.connection.destroy();
        }
      };

      var onEnd = function onEnd() {
        _this3.onData(chunks);

        var headers = {
          // text/html is required instead of text/plain to avoid an
          // unwanted download dialog on certain user-agents (GH-43)
          "Content-Type": "text/html",
          "Content-Length": 2
        };
        res.writeHead(200, _this3.headers(req, headers));
        res.end("ok");
        cleanup();
      };

      req.on("close", onClose);
      if (!isBinary) req.setEncoding("utf8");
      req.on("data", onData);
      req.on("end", onEnd);
    }
    /**
     * Processes the incoming data payload.
     *
     * @param {String} encoded payload
     * @api private
     */

  }, {
    key: "onData",
    value: function onData(data) {
      var _this4 = this;

      debug('received "%s"', data);

      var callback = function callback(packet) {
        if ("close" === packet.type) {
          debug("got xhr close packet");

          _this4.onClose();

          return false;
        }

        _this4.onPacket(packet);
      };

      if (this.protocol === 3) {
        this.parser.decodePayload(data, callback);
      } else {
        this.parser.decodePayload(data).forEach(callback);
      }
    }
    /**
     * Overrides onClose.
     *
     * @api private
     */

  }, {
    key: "onClose",
    value: function onClose() {
      if (this.writable) {
        // close pending poll request
        this.send([{
          type: "noop"
        }]);
      }

      _get(_getPrototypeOf(Polling.prototype), "onClose", this).call(this);
    }
    /**
     * Writes a packet payload.
     *
     * @param {Object} packet
     * @api private
     */

  }, {
    key: "send",
    value: function send(packets) {
      var _this5 = this;

      this.writable = false;

      if (this.shouldClose) {
        debug("appending close packet to payload");
        packets.push({
          type: "close"
        });
        this.shouldClose();
        this.shouldClose = null;
      }

      var doWrite = function doWrite(data) {
        var compress = packets.some(function (packet) {
          return packet.options && packet.options.compress;
        });

        _this5.write(data, {
          compress: compress
        });
      };

      if (this.protocol === 3) {
        this.parser.encodePayload(packets, this.supportsBinary, doWrite);
      } else {
        this.parser.encodePayload(packets, doWrite);
      }
    }
    /**
     * Writes data as response to poll request.
     *
     * @param {String} data
     * @param {Object} options
     * @api private
     */

  }, {
    key: "write",
    value: function write(data, options) {
      var _this6 = this;

      debug('writing "%s"', data);
      this.doWrite(data, options, function () {
        _this6.req.cleanup();
      });
    }
    /**
     * Performs the write.
     *
     * @api private
     */

  }, {
    key: "doWrite",
    value: function doWrite(data, options, callback) {
      var _this7 = this;

      // explicit UTF-8 is required for pages not served under utf
      var isString = typeof data === "string";
      var contentType = isString ? "text/plain; charset=UTF-8" : "application/octet-stream";
      var headers = {
        "Content-Type": contentType
      };

      var respond = function respond(data) {
        headers["Content-Length"] = "string" === typeof data ? Buffer.byteLength(data) : data.length;

        _this7.res.writeHead(200, _this7.headers(_this7.req, headers));

        _this7.res.end(data);

        callback();
      };

      if (!this.httpCompression || !options.compress) {
        respond(data);
        return;
      }

      var len = isString ? Buffer.byteLength(data) : data.length;

      if (len < this.httpCompression.threshold) {
        respond(data);
        return;
      }

      var encoding = accepts(this.req).encodings(["gzip", "deflate"]);

      if (!encoding) {
        respond(data);
        return;
      }

      this.compress(data, encoding, function (err, data) {
        if (err) {
          _this7.res.writeHead(500);

          _this7.res.end();

          callback(err);
          return;
        }

        headers["Content-Encoding"] = encoding;
        respond(data);
      });
    }
    /**
     * Compresses data.
     *
     * @api private
     */

  }, {
    key: "compress",
    value: function compress(data, encoding, callback) {
      debug("compressing");
      var buffers = [];
      var nread = 0;
      compressionMethods[encoding](this.httpCompression).on("error", callback).on("data", function (chunk) {
        buffers.push(chunk);
        nread += chunk.length;
      }).on("end", function () {
        callback(null, Buffer.concat(buffers, nread));
      }).end(data);
    }
    /**
     * Closes the transport.
     *
     * @api private
     */

  }, {
    key: "doClose",
    value: function doClose(fn) {
      var _this8 = this;

      debug("closing");
      var closeTimeoutTimer;

      if (this.dataReq) {
        debug("aborting ongoing data request");
        this.dataReq.destroy();
      }

      var onClose = function onClose() {
        clearTimeout(closeTimeoutTimer);
        fn();

        _this8.onClose();
      };

      if (this.writable) {
        debug("transport writable - closing right away");
        this.send([{
          type: "close"
        }]);
        onClose();
      } else if (this.discarded) {
        debug("transport discarded - closing right away");
        onClose();
      } else {
        debug("transport not writable - buffering orderly close");
        this.shouldClose = onClose;
        closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);
      }
    }
    /**
     * Returns headers for a response.
     *
     * @param {http.IncomingMessage} request
     * @param {Object} extra headers
     * @api private
     */

  }, {
    key: "headers",
    value: function headers(req, _headers) {
      _headers = _headers || {}; // prevent XSS warnings on IE
      // https://github.com/LearnBoost/socket.io/pull/1333

      var ua = req.headers["user-agent"];

      if (ua && (~ua.indexOf(";MSIE") || ~ua.indexOf("Trident/"))) {
        _headers["X-XSS-Protection"] = "0";
      }

      this.emit("headers", _headers, req);
      return _headers;
    }
  }, {
    key: "name",
    get: function get() {
      return "polling";
    }
  }]);

  return Polling;
}(Transport);

module.exports = Polling;